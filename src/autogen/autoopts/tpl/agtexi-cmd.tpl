[= AutoGen5 template -*- Mode: texinfo -*-

texi

#  Documentation template
#
# Time-stamp:        "2012-02-18 09:30:42 bkorb"
# Author:            Bruce Korb <bkorb@gnu.org>
#
#  This file is part of AutoOpts, a companion to AutoGen.
#  AutoOpts is free software.
#  AutoOpts is Copyright (c) 1992-2012 by Bruce Korb - all rights reserved
#
#  AutoOpts is available under any one of two licenses.  The license
#  in use must be one of these two and the choice is under the control
#  of the user of the license.
#
#   The GNU Lesser General Public License, version 3 or later
#      See the files "COPYING.lgplv3" and "COPYING.gplv3"
#
#   The Modified Berkeley Software Distribution License
#      See the file "COPYING.mbsd"
#
#  These files have the following md5sums:
#
#  43b91e8ca915626ed3818ffb1b71248b COPYING.gplv3
#  06a1a2e4760c90ea5e1dad8dfaac4d39 COPYING.lgplv3
#  66a5cedaf62c4b2637025f049f9b826f COPYING.mbsd

=][=

INVOKE initialization                   =][=

(out-push-new (string-substitute (out-name) ".texi" ".menu"))

(ag-fprintf 0 "* %-32s Invoking %s\n"
    (string-append program-name " Invocation::")
    program-name )

(out-pop)
(if (exist? "explain")
    (emit (string-append "\n" (get "explain") "\n")) )
(set! tmp-str (get "option-doc-format" "texi"))
(divert-convert tmp-str)

(join "\n\n"
    (if (exist? "prog-descrip")
        (stack  "prog-descrip")
        (if (exist? "prog-man-descrip")
            (stack  "prog-man-descrip")
            (if (exist? "prog-info-descrip")
                (stack  "prog-info-descrip")
                (stack  "detail")
)   )   )   )

=][=

(convert-divert) =]

This [=(string-downcase doc-level)=] was generated by @strong{AutoGen},
using the @code{agtexi-cmd} template and the option descriptions for the [=(.
coded-prog-name)=] program.[= (name-copyright) =]
[=

IF (. print-menu)           =][=
   INVOKE emit-top-menu     =][=
ENDIF                       =][=

(set! tmp-str (string-append program-name " usage (" help-opt ")"))
(sprintf doc-node-fmt "usage" tmp-str) =]
@cindex [=(. down-prog-name)=] usage

This is the automatically generated usage text for [=prog-name=]:

@exampleindent 0
@example
[=
(shellf "PROG=./%1$s

    if [ ! -f ${PROG} ]
    then PROG=`echo $PROG | tr '[A-Z]' '[a-z]'` ; fi

    if [ ! -f ${PROG} ]
    then PROG=`echo $PROG | tr x_ x-` ; fi

    if [ ! -f ${PROG} ]
    then if %1$s %2$s > /dev/null 2>&1
         then PROG=`command -v %1$s`
         else PROG='echo %1$s is unavailable - no'
    fi ; fi

    ${PROG} %2$s 2>&1 | \
        sed -e 's/USAGE:  lt-/USAGE:  /' \
            -e 's/@/@@/g;s/{/@{/g;s/}/@}/g' \
            -e 's/\t/        /g' "

    program-name help-opt
)  =]
@end example
@exampleindent 4[=

;;  FOR all options, except the `documentation' options, ...
;;
(define opt-name       "")
(define extra-ct       0)
(define extra-text     "")
(define optname-from "A-Z_^")
(define optname-to   "a-z--")

(if (exist? "preserve-case") (begin
   (set! optname-from "_^")
   (set! optname-to   "--") ))  =][=#

@c = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =][=

FOR flag                        =][=

  IF (not (exist? "documentation")) =][=

    (set! opt-name (string-tr! (get "name") optname-from optname-to))
    (out-push-new (shellf "echo ${tmp_dir}/opt-text-%s" opt-name)) =][=
    IF (exist? "aliases")       =][=
      INVOKE emit-aliases       =][=
    ELSE                        =][=
      INVOKE emit-opt-text      =][=
    ENDIF                       =][=
    (out-pop)                   =][=

  ENDIF documentation exists    =][=

ENDFOR flag                     =][=

`cat ${tmp_dir}/opt-text-*
rm -rf ${tmp_dir}`              =][=

IF
   (define home-rc-files (exist? "homerc"))
   (define environ-init  (exist? "environrc"))
   (or home-rc-files environ-init)
   =][=

   INVOKE emit-presets          =][=

ENDIF

@c = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =]
[= (print-node "exit status" (string-append program-name " exit status")) =]

One of the following exit values will be returned:
@table @samp
@item 0
[=(get "exit-desc[0]" "Successful program execution.")=]
@item 1
[= (out-push-new) (out-suspend "doc-sec")
   (get "exit-desc[1]"
        "The operation failed or the command syntax was not valid.") =][=

FOR exit-desc (for-from 2)   =][=
 (sprintf "\n@item %d\n%s" (for-index)
 (get (sprintf "exit-desc[%d]" (for-index))))        =][=
ENDFOR exit-desc                        =][=

FOR doc-section                         =][=

  IF  (define opt-name (string-capitalize! (get "ds-type")))
      (set! tmp-str (sprintf exit-sts-fmt down-prog-name opt-name sub-level))

      (== opt-name "Exit Status")       =][=
    (. tmp-str)                         =][=
  ELSE                                  =][= DEBUG =][=
    (out-resume "doc-sec")
    (emit tmp-str)
    (define cvt-fn (get "ds-format" "texi"))
    (if (not (== cvt-fn "texi"))
        (divert-convert cvt-fn) ) =][=
    (emit (string-append "\n" (get "ds-text") "\n"))
    (convert-divert)
    (out-suspend "doc-sec")             =][=
  ENDIF                                 =][=

ENDFOR  doc-section                    \=]

@end table
[=
(out-resume "doc-sec") (out-pop #t)     =][=#

@c = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =][=

DEFINE emit-top-menu            =]
@menu
[=
  (ag-fprintf 0 "* %s %-24s %s usage (%s)\n"
      down-prog-name "usage::" program-name help-opt)
  (out-push-new)
  =][=

FOR flag                                =][=

  IF (not (exist? "documentation"))     =][=

 (define opt-name (string-tr! (get "name") "A-Z^_" "a-z--"))
 (sprintf "* %s %-24s %s option" down-prog-name
         (string-append opt-name " ::") opt-name)
  =][= % value " (-%s)" =]
[=ENDIF                                 =][=

ENDFOR flag                             =][=

  (shell (string-append
   "{ sort | sed 's/ ::/:: /'\n} <<\\" heredoc-marker
   (out-pop #t) heredoc-marker))        =][=

IF
   (define home-rc-files (exist? "homerc"))
   (define environ-init  (exist? "environrc"))
   (or home-rc-files environ-init)

  =][=
  (sprintf "\n* %s %-24s %s" down-prog-name "option presets::"
           (string-append "presetting/configuring " down-prog-name) )
  =][=

ENDIF                                 =][=

(shell (string-append
"{ sort -u | while read line ; do test -n \"${line}\" && \
     printf '\\n* " down-prog-name " %-24s %s' \"${line}::\" \"${line}\"
   done } <<-\\" heredoc-marker "exit status\n"
   (string-capitalize! (stack-join "\n" "doc-section.ds-type"))
 "\n" heredoc-marker ))

=]
@end menu
[=

ENDDEF emit-top-menu

@c = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =][=

DEFINE emit-aliases             =][=

(set! tmp-str (string-append opt-name " option"))
   (if (exist? "value")
       (set! tmp-str (string-append tmp-str " (-" (get "value") ")")) )
   (print-node opt-name tmp-str) =]
@cindex [=(. down-prog-name)=]-[=(. opt-name)=]

This is an alias for the [= aliases =] option,
[= (sprintf "@pxref{%1$s %2$s, the %2$s documentation}.\n"
      down-prog-name (get "aliases")) =][=

ENDDEF emit-aliases

@c = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =][=

DEFINE emit-opt-text            =]
[= (set! tmp-str (string-append opt-name " option"))
   (if (exist? "value")
       (set! tmp-str (string-append tmp-str " (-" (get "value") ")")) )
   (print-node opt-name tmp-str) =]
@cindex [=(. down-prog-name)=]-[=(. opt-name)=]

This is the ``[=(string-downcase! (get "descrip"))=]'' option.[=
    (set! extra-ct 0)
    (out-push-new)  =][=

    IF (exist? "min") =]@item
is required to appear on the command line.
[=    (set! extra-ct (+ extra-ct 1)) =][=
    ENDIF=][=

    IF (exist? "max") =]@item
may appear [=
      IF % max (== "%s" "NOLIMIT")
         =]an unlimited number of times[=
      ELSE
         =]up to [=max=] times[=
      ENDIF=].
[=    (set! extra-ct (+ extra-ct 1)) =][=
    ENDIF=][=

    IF (exist? "enabled") =]@item
is enabled by default.
[=    (set! extra-ct (+ extra-ct 1)) =][=
    ENDIF=][=

    IF (exist? "ifdef") =]@item
must be compiled in by defining @code{[=(get "ifdef")
      =]} during the compilation.
[=    (set! extra-ct (+ extra-ct 1)) =][=
    ENDIF =][=

    IF (exist? "ifndef") =]@item
must be compiled in by @strong{un}-defining @code{[=(get "ifndef")
      =]} during the compilation.
[=    (set! extra-ct (+ extra-ct 1)) =][=
    ENDIF=][=

    IF (exist? "no_preset") =]@item
may not be preset with environment variables or configuration (rc/ini) files.
[=    (set! extra-ct (+ extra-ct 1)) =][=
    ENDIF=][=

    IF (exist? "equivalence") =]@item
is a member of the [=equivalence=] class of options.
[=    (set! extra-ct (+ extra-ct 1)) =][=
    ENDIF=][=

    IF (exist? "flags_must") =]@item
must appear in combination with the following options:
[=    FOR flags_must ", " =][=flags_must=][=
      ENDFOR=].
[=    (set! extra-ct (+ extra-ct 1)) =][=
    ENDIF=][=

    IF (exist? "flags_cant") =]@item
must not appear in combination with any of the following options:
[=    FOR flags_cant ", " =][=flags_cant=][=
      ENDFOR=].
[=    (set! extra-ct (+ extra-ct 1)) =][=
    ENDIF=][=

    IF  (~* (get "arg-type") "key|set") =]@item
This option takes a keyword as its argument[=

      CASE arg-type   =][=
      =* key          =][= (set! extra-ct (+ extra-ct 1)) =].
The argument sets an enumeration value that can be tested by comparing[=

      =* set          =][= (set! extra-ct (+ extra-ct 1)) =] list.
Each entry turns on or off membership bits.  These bits can be tested
with bit tests against[=
      ESAC arg-type   =] the option value macro ([=
(string-upcase (string-append
(if (exist? "prefix") (string-append (get "prefix") "_") "")
"OPT_VALUE_" (get "name")  )) =]).
The available keywords are:
@example
[= (shell (string-append
   "${CLexe:-columns} -I4 --spread=1 -W50 <<\\" heredoc-marker
   (join "\n" (stack "keyword") "\n")
   heredoc-marker
   )  ) =]
@end example
[=

      IF (=* (get "arg-type") "key") =]
or their numeric equivalent.[=
      ENDIF =][=

    ENDIF key/set arg =][=

    IF (> extra-ct 0) =][=
      (set! extra-text (out-pop #t)) =]

This option has some usage constraints.  It:
@itemize @bullet
[=(. extra-text)
=]@end itemize
[=  ELSE  =][=
      (out-pop) =][=
    ENDIF =][=

?% doc "\n%s" "\nThis option has no @samp{doc} documentation." =][=
  IF (exist? "deprecated") =]

@strong{NOTE: THIS OPTION IS DEPRECATED}[=

  ENDIF     =][=

ENDDEF emit-opt-text

@c = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =][=

DEFINE set-home-rc-vars          =][=
  CASE homerc                    =][=
  ==*  '$@'                      =][=
       (set! explain-pkgdatadir #t)
       (set! cfg-file-name (string-substitute (get "homerc")
          "$@" "$(pkgdatadir)")) =][=

  ==   '.'                       =][=
       (set! cfg-file-name "$PWD")
       (set! env-var-list (string-append env-var-list "PWD, "))
       =][=

  ==*  './'                      =][=
       (set! explain-pkgdatadir #t)
       (set! env-var-list  (string-append env-var-list "PWD, "))
       (set! cfg-file-name (string-append "$PWD" (substring (get "homerc") 1)))
       =][=

  ~~*  '\$[A-Za-z]'              =][=
       (set! cfg-file-name (get "homerc"))
       (set! env-var-list (string-append env-var-list
             (shellf "echo '%s' | sed 's/^.//;s#/.*##'" cfg-file-name)
             ", " ))
       =][=

  == "" =][= (set! cfg-file-name "") =][=

  *                              =][=
       (set! cfg-file-name (get "homerc"))  =][=
  ESAC                           =][=

  (if (> (string-length cfg-file-name) 0)
      (sprintf "\nitem\n%s\n" cfg-file-name) )
  =][=

ENDDEF set-home-rc-vars

@c = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =][=

DEFINE emit-multiple-rc         \=]
[=
  (define explain-pkgdatadir #f)
  (define env-var-list       "")
  rc-count =] places for configuration files:
@itemize @bullet[=
FOR homerc                       =][=
  INVOKE set-home-rc-vars        =][=
ENDFOR homerc                    =]
@end itemize[=
 (if explain-pkgdatadir (ag-fprintf 0
"\nThe value for @code{$(pkgdatadir)} is recorded at package configure time
and replaced by @file{libopts} when @file{%s} runs." program-name))

(if (> (string-length env-var-list) 1)
    (shell (string-append
"list='@code{'`echo '" env-var-list "' | \
  sed -e 's#, $##' \
      -e 's#, #}, @code{#g' \
      -e 's#, \\([^ ][^ ]*\\)$#, and \\1#'`\\}
echo
echo 'The environment variables' ${list}
echo 'are expanded and replaced when @file{" program-name "} runs.'"
))  ) =]
For any of these that are plain files, they are simply processed.
For any that are directories, then a file named @file{[=
 (if (exist? "rcfile") (get "rcfile")
     (string-append "." program-name "rc"))=]} is searched for
within that directory and processed.
[=

ENDDEF emit-multiple-rc

@c = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =][=

DEFINE emit-one-rc-dir              =][=
  (define env-var-list       "")
  (define explain-pkgdatadir #f)    =][=
  INVOKE set-home-rc-vars

=]@file{[=(. cfg-file-name) =]} for configuration.[=
  IF (. explain-pkgdatadir)         =]
The value for @code{$(pkgdatadir)} is recorded at package configure time
and replaced by @file{libopts} when @file{[=prog-name=]} runs.
[=ENDIF=][=
(if (> (string-length env-var-list) 1)
    (sprintf
"\nThe environment variable @code{%s} is expanded and replaced when
the program runs" env-var-list)) =]
If this is a plain file, it is simply processed.
If it is a directory, then a file named @file{[=
(if (exist? "rcfile") (get "rcfile")
     (string-append "." program-name "rc"))
=]} is searched for within that directory.[=

ENDDEF emit-one-rc-dir

@c = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =][=

DEFINE emit-rc-file-info                =]

@code{libopts} will search in [=

    IF (define rc-count (count "homerc"))
       (define cfg-file-name "")
       (> rc-count 1)           =][=

       INVOKE emit-multiple-rc  =][=
    
    ELSE                        =][=
       INVOKE emit-one-rc-dir   =][=
    ENDIF (> rc-count 1)

=]

Configuration files may be in a wide variety of formats.
The basic format is an option name followed by a value (argument) on the
same line.  Values may be separated from the option name with a colon,
equal sign or simply white space.  Values may be continued across multiple
lines by escaping the newline with a backslash.

Multiple programs may also share the same initialization file.
Common options are collected at the top, followed by program specific
segments.  The segments are separated by lines like:
@example
[[=(. UP-PROG-NAME)=]]
@end example
@noindent
or by
@example
<?program [= prog-name =]>
@end example
@noindent
Do not mix these within one configuration file.

Compound values and carefully constructed string values may also be
specified using XML syntax:
@example
<option-name>
   <sub-opt>...&lt;...&gt;...</sub-opt>
</option-name>
@end example
@noindent
yielding an @code{option-name.sub-opt} string value of
@example
"...<...>..."
@end example
@code{AutoOpts} does not track suboptions.  You simply note that it is a
hierarchicly valued option.  @code{AutoOpts} does provide a means for searching
the associated name/value pair list (see: optionFindValue).[=

ENDDEF emit-rc-file-info

@c = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =][=

DEFINE emit-presets                     =]

[= (print-node "option presets"
   (string-append "presetting/configuring " program-name) ) =]

Any option that is not marked as @i{not presettable} may be preset by
loading values from [=
IF
   (if home-rc-files (emit
       "configuration (\"rc\" or \"ini\") files"))
   environ-init
  =][=
  (if home-rc-files (emit ", and values from "))
  =]environment variables named @code{[=(. UP-PROG-NAME)=]} and @code{[=
(. UP-PROG-NAME)=]_<OPTION_NAME>}.  @code{<OPTION_NAME>} must be one of
the options listed above in upper case and segmented with underscores.
The @code{[=(. UP-PROG-NAME)=]} variable will be tokenized and parsed like
the command line.  The remaining variables are tested for existence and their
values are treated like option arguments[=
  ENDIF  have environment inits         =].
[=

  IF (. home-rc-files)                  =][=
     INVOKE emit-rc-file-info           =][=
  ENDIF home-rc-files                   =][=

ENDDEF emit-presets

@c = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =][=

DEFINE header                          \=]
\input texinfo
@c -*-texinfo-*-
@c %**start of header
@setfilename [= (define sub-level "chapter") file-name =]
@settitle [= (sprintf (if (exist? "package") "%2$s - %1$s" "%s")
             (get "package")  (get "prog-title")) =]
@c %**end of header
@setchapternewpage off
@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{Sample Title}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
[= (name-copyright) =]
@end titlepage
[=

ENDDEF header

@c = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =][=

DEFINE initialization                   =][=

  ;;# START-BUILDTREE-ISMS
  ;;
  (shell "CLexe=${AGexe%/agen5/*}/columns/columns
  test -x \"${CLexe}\" || {
    CLexe=${AGexe%/autogen}/columns
    test -x \"${CLexe}\" || die 'columns program is not findable'
  }")

=][= # END-BUILDTREE-ISMS

  (shell "CLexe=${AGexe%/autogen}/columns")

# END-INSTALL-ONLY-CODE =][=

  ;; divert-convert  divert text for conversion to .texi format
  ;; convert-divert  convert the diversion done with divert-convert
  ;;
  (define divert-convert (lambda (diversion-type) (begin
     (set! was-diverted
           (not (or (== diversion-type "texi") (== diversion-type ""))))
     (if was-diverted   (begin
         (set! cvt-script
               (find-file (string-append diversion-type "2texi")))
         (if (not (defined? 'cvt-script))
             (error (sprintf "unknown source format type: %s" diversion-type)) )
         (out-push-new) ))  )))

  (define heredoc-marker "_Unlikely_Here_Doc_Marker_\n")
  (define convert-divert (lambda ()
     (if was-diverted (shell (string-append
         cvt-script "<<\\" heredoc-marker (out-pop #t) "\n" heredoc-marker
  )) )))

  (define was-diverted   #f)
  (define diversion-type "")
  (define cvt-script     "")
  (define tmp-str        "")

  (define name-copyright (lambda ()
      (if (exist? "copyright")
          (string-append "\nThis software is released under "
             (license-name (get "copyright.type" "an unknown copyright"))
             "." ) ) ))

  (make-tmp-dir)
  (define program-name      (get "prog-name"))
  (define down-prog-name    (string-downcase program-name))
  (define UP-PROG-NAME      (string-upcase   program-name))
  (define doc-level         (getenv "LEVEL"))
  (if (not (string? doc-level))
      (set! doc-level "section"))
  (define file-name         (string-append down-prog-name ".texi"))
  (define coded-prog-name   (string-append "@code{" down-prog-name "}"))

  (define replace-prog-name (lambda (nm)
     (string-substitute (get nm) down-prog-name coded-prog-name )  ))

  (define usage-nodes       (getenv "USAGE_NODES"))
  (if (not (string? usage-nodes))
      (set! usage-nodes "each"))

  (define print-node (lambda (a b) (sprintf node-fmt a b) ))
  (define print-menu   #t)
  (define do-doc-nodes #f)

  (define help-opt
         (if (exist? "help-value")     (string-append "-" (get "help-value"))
         (if (exist? "flag.value")     "-?"
         (if (exist? "long-opts")      "--help"
                                       "help" ))) )
  =][=


  CASE (. doc-level)    =][=
    == document         =][= INVOKE header =][=
    == chapter          =][= (define sub-level "section")       =][=
    == section          =][= (define sub-level "subsection")    =][=
    == subsection       =][= (define sub-level "subsubsection") =][=

    * =][=(error (sprintf "invalid doc level: %s\n" doc-level)) =][=

  ESAC documentation level  =][=


  CASE (define node-fmt "") (define doc-node-fmt "")
       usage-nodes      =][=

  ==  each              =][=
     (set! node-fmt (string-append
        "\n@node " down-prog-name " %s\n@" sub-level " %s"))
     (set! doc-node-fmt node-fmt)
     (define exit-sts-fmt "\n\n@node %1$s %2$s\n@%3$s %1$s %2$s\n")
     =][=

  ==  none              =][=

     (set! print-menu #f)
     (set! node-fmt (string-append
        "\n@anchor{" down-prog-name " %s}\n@subheading %s"))
     (set! doc-node-fmt node-fmt)
     (define exit-sts-fmt "\n\n@anchor{%1$s %2$s}\n@subheading %1$s %2$s\n")
     =][=

  ==* doc               =][=
     (set! doc-node-fmt (string-append
        "\n@node " down-prog-name " %s\n@" sub-level " %s"))
     (if (exist? "flag.documentation")
         (begin
            (set! do-doc-nodes #t)
            (set! node-fmt (string-append
               "\n@anchor{" down-prog-name " %s}\n@subheading %s"))
         )
         (begin
            (set! do-doc-nodes #f)
            (set! node-fmt doc-node-fmt)
     )   )
            
     (define exit-sts-fmt "\n\n@anchor{%1$s %2$s}\n@subheading %1$s %2$s\n")
     =][=

  *                     =][=
     (error (string-append "indecipherable USAGE_NODES:  " usage-nodes))
     =][=

  ESAC                  =][=


  IF (not (== doc-level "document"))    =][=
     (set! file-name (string-append "invoke-" file-name))
       \=]
@node [= prog-name      =] Invocation
@[=(. doc-level)        =] Invoking [= prog-name =]
@pindex [= prog-name    =]
@cindex [= prog-title   =][=

FOR concept =]
@cindex [= concept      =][=
ENDFOR                  =][=

  ENDIF document component

=]
@ignore
[=

(out-move file-name)
(dne "# " "# ")

=]
@end ignore
[=

ENDDEF initialization

@c agtexi-cmd.tpl ends here =]
