/* *INDENT-OFF* */ /* ATTR_FORMAT confuses indent, avoid running it for now */
/* defs.h: Basic, host-specific, and target-specific definitions for GDB.
   Copyright 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#ifndef DEFS_H
#define DEFS_H

/* just to make the header guard a little less ambiguous: */
#ifndef __GDB_DEFS_H__
# define __GDB_DEFS_H__ 1
#endif /* !__GDB_DEFS_H__ */

#if defined(WITH_GNULIB_BUILDDIR)
# include "build-gnulib/../config.h"
#endif /* WITH_GNULIB_BUILDDIR */

#ifdef HAVE_CONFIG_H
# include "config.h" /* Generated by configure.  */
#else
# if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #  warning defs.h expects "config.h" to be included.
# endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* HAVE_CONFIG_H */

#ifdef __NeXT__
# ifdef __restrict
#  undef __restrict
# endif /* __restrict */
# ifdef _FORTIFY_SOURCE
#  undef _FORTIFY_SOURCE
# endif /* _FORTIFY_SOURCE */
# ifdef _USE_FORTIFY_LEVEL
#  undef _USE_FORTIFY_LEVEL
# endif /* _USE_FORTIFY_LEVEL */
# ifndef _SECURE__STDIO_H_
#  define _SECURE__STDIO_H_ 1
# endif /* !_SECURE__STDIO_H_ */
#endif /* __NeXT__ */

#ifndef __has_include
# define __has_include(foo) 0
#endif /* !__has_include */

#ifdef TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if defined(HAVE_SYS_TIME_H) || __has_include(<sys/time.h>)
#  include <sys/time.h>
# else
#  if defined(HAVE_TIME_H) || __has_include(<time.h>)
#   include <time.h>
#  else
#   if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #    warning "defs.h expects a time-related header to be included."
#   endif /* __GNUC__ && !__STRICT_ANSI__ */
#  endif /* HAVE_TIME_H */
# endif /* HAVE_SYS_TIME_H */
#endif /* TIME_WITH_SYS_TIME */

#if defined(HAVE_SYS_TYPES_H) || defined(STDC_HEADERS) || defined(__STDC__) || \
    defined(__GNUC__) || defined(__APPLE__) || __has_include(<sys/types.h>)
# include <sys/types.h>
#else
# if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #  warning "defs.h expects <sys/types.h> to be included."
# endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* HAVE_SYS_TYPES_H || STDC_HEADERS || __STDC__ || __GNUC__ || __APPLE__ */

#if defined(HAVE_STDIO_H) || defined(STDC_HEADERS) || defined(__STDC__) || \
    defined(__GNUC__) || defined(__APPLE__) || __has_include(<stdio.h>)
# include <stdio.h>
#else
# if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #  warning "defs.h expects <stdio.h> to be included."
# endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* HAVE_STDIO_H */
#if defined(HAVE_ERRNO_H) || defined(STDC_HEADERS) || defined(__STDC__) || \
    defined(__GNUC__) || defined(__APPLE__) || __has_include(<errno.h>)
# include <errno.h> /* System call error return status.  */
#else
# if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #  warning "defs.h expects <errno.h> to be included."
# endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* HAVE_ERRNO_H */
#ifdef HAVE_LIMITS_H
# include <limits.h>
#else
# if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #  warning "defs.h expects <limits.h> to be included."
# endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* HAVE_LIMITS_H */
#if defined(HAVE_STRING_H) || __has_include(<string.h>)
# include <string.h>
#else
# if defined(HAVE_STRINGS_H) || __has_include(<strings.h>)
#  include <strings.h>
# else
#  if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #   warning "defs.h expects either <string.h> or <strings.h> to be included."
#  endif /* __GNUC__ && !__STRICT_ANSI__ */
# endif /* HAVE_STRINGS_H */
#endif /* HAVE_STRING_H */
#if defined(HAVE_REGEX_H) || defined(__GNUC__) || __has_include(<regex.h>)
# include <regex.h>
#else
# if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #  warning "defs.h expects <regex.h> to be included."
# endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* HAVE_REGEX_H */

#if defined(HAVE_STDDEF_H) || __has_include(<stddef.h>)
# include <stddef.h>
#else
# if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #  warning "defs.h expects <stddef.h> to be included."
# endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* HAVE_STDDEF_H */

#if defined(HAVE_UNISTD_H) || __has_include(<unistd.h>)
# include <unistd.h>
#else
# if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #  warning "defs.h expects <unistd.h> to be included."
# endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* HAVE_UNISTD_H */

/* APPLE LOCAL:
 * #ifdef HAVE_SARCASM
 * # warning We use radical new-wave C language features like "uint32_t"!
 * #endif
 * (Note: The above is NOT actually a preprocessor macro that can actually
 * be uncommented; rather, it is a weak attempt at humor) */
#if defined(HAVE_STDINT_H) || __has_include(<stdint.h>)
# include <stdint.h>
#else
# if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #  warning "defs.h expects <stdint.h> to be included."
# endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* HAVE_STDINT_H */

/* First include ansidecl.h so we can use the various macro definitions
 * here and in all subsequent file inclusions: */
#include "ansidecl.h"

#include "gdb_locale.h"

/* For ``enum target_signal''.  */
#include "gdb/signals.h"

/* Just in case they are not defined in your stdio.h header: */
#ifndef SEEK_SET
# define SEEK_SET 0
#endif /* !SEEK_SET */
#ifndef SEEK_CUR
# define SEEK_CUR 1
#endif /* !SEEK_CUR */

#if defined(HAVE_STDARG_H) || defined(STDC_HEADERS) || defined(__STDC__) || \
    defined(__GNUC__) || defined(__APPLE__) || __has_include(<stdarg.h>)
# include <stdarg.h> /* For va_list.  */
#else
# if defined(HAVE_VARARGS_H) || __has_include(<varargs.h>)
#  include <varargs.h>
# else
#  if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #   warning "defs.h expects either <stdarg.h> or <varargs.h> to be included."
#  endif /* __GNUC__ && !__STRICT_ANSI__ */
# endif /* HAVE_VARARGS_H */
#endif /* HAVE_STDARG_H */

/* 0 means unavailable; needs to go before "libiberty.h" for -Wundef: */
#ifndef HAVE_DECL_BASENAME
# define HAVE_DECL_BASENAME 0
#endif /* !HAVE_DECL_BASENAME */

#include "libiberty.h"

/* Rather than duplicate all the logic in BFD for figuring out what types
 * to use (which can be pretty complicated), simply define them in terms
 * of the corresponding type from BFD: */
#include "bfd.h"

/* NLS (from gettext/libintl) might be needed: */
#ifdef ENABLE_NLS
# if defined(HAVE_LIBINTL_H) || __has_include(<libintl.h>)
#  include <libintl.h>
#  define _(String) gettext (String)
#  ifdef gettext_noop
#   define N_(String) gettext_noop (String)
#  else
#   define N_(String) (String)
#  endif /* gettext_noop */
#  ifndef gettext
#   define gettext(Msgid) (Msgid)
#  endif /* !gettext */
#  ifndef dgettext
#   define dgettext(Domainname, Msgid) (Msgid)
#  endif /* !dgettext */
#  ifndef dcgettext
#   define dcgettext(Domainname, Msgid, Category) (Msgid)
#  endif /* !dcgettext */
#  ifndef textdomain
#   define textdomain(Domainname) while (0) /* nothing */
#  endif /* !textdomain */
#  ifndef bindtextdomain
#   define bindtextdomain(Domainname, Dirname) while (0) /* nothing */
#  endif /* !bindtextdomain */
# else
#  if defined(HAVE_LIBGETTEXT_H) || __has_include(<libgettext.h>)
#   include <libgettext.h>
#  else
#   if defined(HAVE_GETTEXT_H) || __has_include(<gettext.h>)
#    include <gettext.h>
#   else
#    if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #     warning "defs.h expects <libintl.h> (or another similar header) to be included."
#    endif /* __GNUC__ && !__STRICT_ANSI__ */
#   endif /* HAVE_GETTEXT_H */
#  endif /* HAVE_LIBGETTEXT_H */
# endif /* HAVE_LIBINTL_H */
#else
# ifdef HAVE_LIBINTL_H
#  if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #   warning "enable nls to include <libintl.h>"
#  endif /* __GNUC__ && !__STRICT_ANSI__ */
# endif /* HAVE_LIBINTL_H */
# ifndef gettext
#  define gettext(Msgid) (Msgid)
# endif /* !gettext */
# ifndef dgettext
#  define dgettext(Domainname, Msgid) (Msgid)
# endif /* !dgettext */
# ifndef dcgettext
#  define dcgettext(Domainname, Msgid, Category) (Msgid)
# endif /* !dcgettext */
# ifndef textdomain
#  define textdomain(Domainname) while (0) /* nothing */
# endif /* !textdomain */
# ifndef bindtextdomain
#  define bindtextdomain(Domainname, Dirname) while (0) /* nothing */
# endif /* !bindtextdomain */
# ifndef _gettext
#  define _gettext(Msgid) (Msgid)
# endif /* !_gettext */
#endif /* ENABLE_NLS */

/* A byte from the program being debugged: */
typedef bfd_byte gdb_byte;

/* An address in the program being debugged. Host byte order: */
typedef bfd_vma CORE_ADDR;
#define CORE_ADDR_DEFINED 1

/* For use with the CORE_ADDR type: */
#ifndef INVALID_ADDRESS
# define INVALID_ADDRESS ((CORE_ADDR)(-1L))
#endif /* !INVALID_ADDRESS */

/* This is to make sure that LONGEST is at least as big as CORE_ADDR: */
#ifndef LONGEST
# ifdef BFD64
#  define LONGEST BFD_HOST_64_BIT
#  define ULONGEST BFD_HOST_U_64_BIT
# else /* No BFD64 */
#  ifdef CC_HAS_LONG_LONG
#   define LONGEST long long
#   define ULONGEST unsigned long long
#  else
#   ifdef BFD_HOST_64_BIT
/* BFD_HOST_64_BIT is defined for some hosts that do NOT have long long
   (e.g. i386-windows) so try it.  */
#    define LONGEST BFD_HOST_64_BIT
#    define ULONGEST BFD_HOST_U_64_BIT
#   else
#    define LONGEST long
#    define ULONGEST unsigned long
#   endif /* BFD_HOST_64_BIT */
#  endif /* CC_HAS_LONG_LONG */
# endif /* !BFD64 */
#endif /* !LONGEST */

#ifndef min
# define min(a, b) ((a) < (b) ? (a) : (b))
#endif /* !min */
#ifndef max
# define max(a, b) ((a) > (b) ? (a) : (b))
#endif /* !max */

#ifndef PATH_MAX
/* For MAXPATHLEN: */
# if defined(HAVE_SYS_PARAM_H) || __has_include(<sys/param.h>)
#  include <sys/param.h>
# else
#  ifndef MAXPATHLEN
#   if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #    warning "defs.h wants to include <sys/param.h> for MAXPATHLEN"
#   endif /* __GNUC__ && !__STRICT_ANSI__ */
#  endif /* !MAXPATHLEN */
# endif /* HAVE_SYS_PARAM_H */
# ifndef PATH_MAX
#  ifdef MAXPATHLEN
#   define PATH_MAX MAXPATHLEN
#  else
#   define PATH_MAX 1024
#  endif /* MAXPATHLEN */
# endif /* !PATH_MAX */
#endif /* !PATH_MAX */

#ifndef SIZE_T_MAX
# ifdef SIZE_MAX
#  define SIZE_T_MAX SIZE_MAX
# else
#  ifdef ULONG_MAX
#   define SIZE_T_MAX ULONG_MAX	/* max value for a size_t */
#  else
#   ifdef UINT_MAX
#    define SIZE_T_MAX UINT_MAX
#   endif /* UINT_MAX */
#  endif /* ULONG_MAX */
# endif /* SIZE_MAX */
#endif /* !SIZE_T_MAX */

#ifndef BUF_LEN_MAX_FOR_SNPRINTF
# define BUF_LEN_MAX_FOR_SNPRINTF \
           (min((((SIZE_T_MAX - 1UL) / 2UL) - 1UL), ((size_t)INT_MAX - 1UL)))
#endif /* BUF_LEN_MAX_FOR_SNPRINTF */

/* Macros to do string compares.

   NOTE: cagney/2000-03-14:

   While old code can continue to refer to these macros, new code is
   probably better off using strcmp() directly vis: ``strcmp() == 0''
   and ``strcmp() != 0''.

   This is because modern compilers can directly inline strcmp()
   making the original justification for these macros - avoid function
   call overhead by pre-testing the first characters
   (``*X==*Y?...:0'') - redundant.

   ``Even if [...] testing the first character does have a modest
   performance improvement, I'd rather that whenever a performance
   issue is found that we spend the effort on algorithmic
   optimizations than micro-optimizing.'' J.T. */

/* NOTE: cagney/2003-11-23: All instances of STREQ[N] covered by
   testing GDB on a stabs system have been replaced by equivalent
   str[n]cmp calls.  To avoid the possability of introducing bugs when
   making untested changes, the remaining references were deprecated
   rather than replaced.  */

/* DISCLAIMER: cagney/2003-11-23: Simplified definition of these
   macros so that they just map directly onto strcmp equivalent.  I am
   not responsible for any breakage due to code that relied on the old
   underlying implementation.  */

#define DEPRECATED_STREQ(a,b) (strcmp((a), (b)) == 0)
#define DEPRECATED_STREQN(a,b,c) (strncmp((a), (b), (c)) == 0)

#ifndef CPLUS_MARKER
# define CPLUS_MARKER '$' /* May be overridden to '.' for SysV */
#endif /* !CPLUS_MARKER */

/* Check if a character is one of the commonly used C++ marker characters: */
extern int is_cplus_marker(int);

/* enable xdb commands if set */
extern int xdb_commands;

/* enable dbx commands if set */
extern int dbx_commands;

/* System root path, used to find libraries and so on: */
extern const char *gdb_sysroot;

extern int quit_flag;
extern int immediate_quit;
extern int sevenbit_strings;

extern void quit(void);

/* FIXME: cagney/2000-03-13: It has been suggested that the peformance
   benefits of having a ``QUIT'' macro rather than a function are
   marginal.  If the overhead of a QUIT function call is proving
   significant then its calling frequency should probably be reduced
   [kingdon].  A profile analyzing the current situtation is
   needed. */

#ifdef QUIT
/* do twice to force compiler warning */
# define QUIT_FIXME "FIXME"
# define QUIT_FIXME "ignoring redefinition of QUIT"
# if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #  warning "FIXME: ignoring redefinition of QUIT"
# endif /* __GNUC__ && !__STRICT_ANSI__ */
#else
# if defined(deprecated_interactive_hook)
#  define QUIT { \
   if (quit_flag) { quit() }; \
   if (deprecated_interactive_hook) { deprecated_interactive_hook() }; \
}
# else
#  define QUIT { \
   if (quit_flag) quit(); \
}
# endif /* deprecated_interactive_hook */
#endif /* QUIT */

/* Languages represented in the symbol table and elsewhere.
   This should probably be in language.h, but since enum's can't
   be forward declared to satisfy opaque references before their
   actual definition, needs to be here. */

enum language
  {
    language_unknown,		/* Language not known */
    language_auto,		/* Placeholder for automatic setting */
    language_c,			/* C */
    language_cplus,		/* C++ */
    language_objc,		/* Objective-C */
    /* APPLE LOCAL objcplus */
    language_objcplus,		/* Objective-C++ */
    language_java,		/* Java */
    language_chill,		/* Chill */
    language_fortran,		/* Fortran */
    language_m2,		/* Modula-2 */
    language_asm,		/* Assembly language */
    language_scm,    		/* Scheme / Guile */
    language_pascal,		/* Pascal */
    language_ada,		/* Ada */
    language_minimal,	/* All other languages, minimal support only */
    nr_languages
  };

enum precision_type
  {
    single_precision,
    double_precision,
    unspecified_precision
  };

/* A generic, not quite boolean, enumeration: */
enum auto_boolean
{
  AUTO_BOOLEAN_TRUE,
  AUTO_BOOLEAN_FALSE,
  AUTO_BOOLEAN_AUTO
};

/* Potential ways that a function can return a value of a given type.  */
enum return_value_convention
{
  /* Where the return value has been squeezed into one or more
     registers.  */
  RETURN_VALUE_REGISTER_CONVENTION,
  /* Commonly known as the "struct return convention".  The caller
     passes an additional hidden first parameter to the caller.  That
     parameter contains the address at which the value being returned
     should be stored.  While typically, and historically, used for
     large structs, this is convention is applied to values of many
     different types.  */
  RETURN_VALUE_STRUCT_CONVENTION,
  /* Like the "struct return convention" above, but where the ABI
     guarantees that the called function stores the address at which
     the value being returned is stored in a well-defined location,
     such as a register or memory slot in the stack frame.  Don't use
     this if the ABI doesn't explicitly guarantees this.  */
  RETURN_VALUE_ABI_RETURNS_ADDRESS,
  /* Like the "struct return convention" above, but where the ABI
   * guarantees that the address at which the value being returned is
   * stored will be available in a well-defined location, such as a
   * register or memory slot in the stack frame. Do NOT use this if
   * the ABI does NOT explicitly guarantees this. */
  RETURN_VALUE_ABI_PRESERVES_ADDRESS/*,*/
};

/* in case we need this for any structs: */
#ifndef FLEXIBLE_ARRAY_MEMBER
# define FLEXIBLE_ARRAY_MEMBER 1
#endif /* !FLEXIBLE_ARRAY_MEMBER */

/* the cleanup list records things that have to be undone
   if an error happens (descriptors to be closed, memory to be freed, etc.)
   Each link in the chain records a function to call and an
   argument to give it.

   Use make_cleanup to add an element to the cleanup chain.
   Use do_cleanups to do all cleanup actions back to a given
   point in the chain.  Use discard_cleanups to remove cleanups
   from the chain back to a given point, not doing them.  */

struct cleanup
  {
    struct cleanup *next;
    void (*function)(void *);
    void *arg;
  };


/* The ability to declare that a function never returns is useful, but
   not really required to compile GDB successfully, so the NORETURN and
   ATTR_NORETURN macros normally expand into nothing.  */

/* If compiling with older versions of GCC, a function may be declared
   "volatile" to indicate that it does not return.  */

#ifndef NORETURN
# if defined(__GNUC__) \
     && ((__GNUC__ == 1) || ((__GNUC__ == 2) && (__GNUC_MINOR__ < 7)))
#  define NORETURN volatile
# else
#  define NORETURN		/* nothing */
# endif /* __GNUC__ version check */
#endif /* !NORETURN */

/* GCC 2.5 and later versions define a function attribute "noreturn",
   which is the preferred way to declare that a function never returns.
   However GCC 2.7 appears to be the first version in which this fully
   works everywhere we use it. */

#ifndef ATTR_NORETURN
# if defined(__GNUC__) && ((__GNUC__ > 2) || ((__GNUC__ == 2) && (__GNUC_MINOR__ >= 7)))
#  define ATTR_NORETURN __attribute__((noreturn))
# else
#  define ATTR_NORETURN /* nothing */
# endif /* __GNUC__ version check */
#endif /* !ATTR_NORETURN */

/* Added in gcc 7: */
#ifndef ATTR_FALLTHROUGH
# if defined(__GNUC__) && (__GNUC__ >= 7)
#  define ATTR_FALLTHROUGH __attribute__((fallthrough))
# else
#  define ATTR_FALLTHROUGH /* FALLTHRU */
# endif /* gcc 7+ */
#endif /* !ATTR_FALLTHROUGH */

#ifndef ATTR_FORMAT
# if defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 4))
#  define ATTR_FORMAT(type, x, y) __attribute__((format(type, x, y)))
# else
#  define ATTR_FORMAT(type, x, y)	/* nothing */
# endif /* __GNUC__ version check */
#endif /* !ATTR_FORMAT */

#ifndef ATTR_FORMAT_ARG
# if defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 4))
#  define ATTR_FORMAT_ARG(arg) __attribute__((format_arg(arg)))
# else
#  define ATTR_FORMAT_ARG(arg)	/* nothing */
# endif /* __GNUC__ version check */
#endif /* !ATTR_FORMAT_ARG */

#if defined(__GNUC__) && defined(__GNUC_MINOR__)
# if (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3))
#  define ATTRIBUTE_OPTIMIZE(foo) __attribute__((optimize(#foo)))
# else
#  define ATTRIBUTE_OPTIMIZE(foo) /* nothing */
# endif /* gcc 4.3+ (is that the correct version?) */
#else
# define ATTRIBUTE_OPTIMIZE /* (nothing) */
#endif /* any gcc */

/* FIXME: dirty hack: */
#ifndef gnu_printf
# if defined(__clang__) || (defined(__APPLE_CC__) && (__APPLE_CC__ > 1))
#  define gnu_printf printf
# endif /* __clang__ || (__APPLE_CC__ > 1) */
#endif /* !gnu_printf */

/* We use __extension__ in some places to suppress -pedantic warnings
 * about GCC extensions.  This feature did NOT work properly before
 * gcc 2.8.  */
#if !defined(__extension__) && defined(GCC_VERSION)
# if (GCC_VERSION < 2008)
#  define __extension__
# endif /* gcc pre-2.8 */
#endif /* !__extension__ && GCC_VERSION */

/* Be conservative and use enum bitfields only with GCC.
 * This is copied from gcc 3.3.1, <system.h>
 * (and more recently from "../include/ansidecl.h"): */
#ifndef ENUM_BITFIELD
# ifdef __cplusplus
#  define ENUM_BITFIELD(TYPE) enum TYPE
# else
#  if (defined(__GNUC__) && (__GNUC__ >= 2))
#   define ENUM_BITFIELD(TYPE) __extension__ enum TYPE
#  else
#   define ENUM_BITFIELD(TYPE) unsigned int
#  endif /* gcc 2+ */
# endif /* __cplusplus */
#endif /* !ENUM_BITFIELD */

/* Needed for various prototypes */

struct symtab;
struct breakpoint;
struct frame_info;

/* APPLE LOCAL more forward structs */
struct symtab_and_line;
struct ui_out;
struct symbol;


/* APPLE LOCAL begin size */
extern void set_screen_size(void);
extern void set_width(void);
/* APPLE LOCAL end size */

extern void initialize_utils(void);

extern void notice_quit(void);

extern int strcmp_iw(const char *, const char *);

extern int strcmp_iw_ordered(const char *, const char *);

extern int streq(const char *, const char *);

extern int subset_compare(char *, const char *);

extern char *safe_strerror(int) ATTRIBUTE_W_U_R ATTRIBUTE_RETURNS_NONNULL;

/* APPLE LOCAL begin mmalloc */
extern void *init_malloc(void *) ATTRIBUTE_W_U_R ATTRIBUTE_CONST;
extern void init_mmalloc_default_pool(void *);
/* APPLE LOCAL end mmalloc */

extern void request_quit(int);

#define	ALL_CLEANUPS	((struct cleanup *)0)

extern void do_cleanups(struct cleanup *);
extern void do_final_cleanups(struct cleanup *);
extern void do_run_cleanups(struct cleanup *);
extern void do_exec_cleanups(struct cleanup *);
extern void do_exec_error_cleanups(struct cleanup *);
/* APPLE LOCAL: hand_call_cleanups.  */
extern void do_hand_call_cleanups(struct cleanup *);

extern void discard_cleanups(struct cleanup *);
extern void discard_final_cleanups(struct cleanup *);
extern void discard_exec_error_cleanups(struct cleanup *);
/* APPLE LOCAL: hand_call_cleanups.  */
extern void discard_hand_call_cleanups(struct cleanup *old_chain);
extern void discard_my_cleanups(struct cleanup **, struct cleanup *);

/* NOTE: cagney/2000-03-04: This typedef is strictly for the
   make_cleanup function declarations below. Do not use this typedef
   as a cast when passing functions into the make_cleanup() code.
   Instead either use a bounce function or add a wrapper function.
   Calling a f(char*) function with f(void*) is non-portable. */
typedef void (make_cleanup_ftype)(void *);

extern struct cleanup *make_cleanup(make_cleanup_ftype *, void *);

extern struct cleanup *make_cleanup_freeargv(char **);

struct ui_file;
extern struct cleanup *make_cleanup_ui_file_delete(struct ui_file *);

/* APPLE LOCAL begin cleanup */
struct cleanup *make_cleanup_ui_out_delete(struct ui_out *);
struct cleanup *make_cleanup_restore_uiout(struct ui_out *);
struct cleanup *make_cleanup_ui_out_suppress_output(struct ui_out *cur_uiout);
/* APPLE LOCAL end cleanup */

struct section_addr_info;
typedef struct section_addr_info sect_a_i_t;
extern struct cleanup *make_cleanup_free_section_addr_info(sect_a_i_t *);

extern struct cleanup *make_cleanup_close(int fd);

extern struct cleanup *make_cleanup_bfd_close(bfd *abfd);

extern struct cleanup *make_final_cleanup(make_cleanup_ftype *, void *);

extern struct cleanup *make_my_cleanup(struct cleanup **,
                                       make_cleanup_ftype *, void *);

extern struct cleanup *make_run_cleanup(make_cleanup_ftype *, void *);

extern struct cleanup *make_exec_cleanup(make_cleanup_ftype *, void *);
extern struct cleanup *make_exec_error_cleanup(make_cleanup_ftype *, void *);

/* APPLE LOCAL: hand_call_cleanups.  */
extern struct cleanup *make_hand_call_cleanup(make_cleanup_ftype *, void *);

extern struct cleanup *save_cleanups(void);
extern struct cleanup *save_final_cleanups(void);
extern struct cleanup *save_my_cleanups(struct cleanup **);

extern void restore_cleanups(struct cleanup *);
extern void restore_final_cleanups(struct cleanup *);
extern void restore_my_cleanups(struct cleanup **, struct cleanup *);

extern void free_current_contents(void *);

extern void null_cleanup(void *);

extern int myread(int, char *, int);

extern int query(const char *, ...) ATTR_FORMAT(printf, 1, 2);
extern int nquery(const char *, ...) ATTR_FORMAT(printf, 1, 2);
extern int yquery(const char *, ...) ATTR_FORMAT(printf, 1, 2);

extern void init_page_info(void);

extern char *gdb_realpath(const char *) ATTRIBUTE_W_U_R;
extern char *xfullpath(const char *) ATTRIBUTE_W_U_R;

extern unsigned long gnu_debuglink_crc32(unsigned long crc,
                                         unsigned char *buf, size_t len);

extern const char *bundle_basename(const char *filepath) ATTRIBUTE_W_U_R;

extern void unlimit_file_rlimit(void);
extern void restore_file_rlimit(void);

/* From demangle.c */

extern void set_demangling_style(const char *);

/* APPLE LOCAL fix-and-continue */
/* From fix-and-continue.h */

extern CORE_ADDR decode_fix_and_continue_trampoline(CORE_ADDR);
extern void update_picbase_register(struct symbol *);
extern void fix_command_1(const char *, const char *, const char *);
extern int fix_and_continue_supported(void);
extern int file_exists_p(const char *);

/* From tm.h */

struct type;
typedef int (use_struct_convention_fn)(int gcc_p, struct type *value_type);
extern use_struct_convention_fn generic_use_struct_convention;


/* Annotation stuff.  */

extern int annotation_level;	/* in stack.c */

extern void begin_line(void);

extern void wrap_here(const char *);

extern void reinitialize_more_filter(void);

/* Normal results */
extern struct ui_file *gdb_stdout;
/* Input stream */
extern struct ui_file *gdb_stdin;
/* Serious error notifications */
extern struct ui_file *gdb_stderr;
/* Log/debug/trace messages that should bypass normal stdout/stderr
   filtering.  For moment, always call this stream using
   *_unfiltered. In the very near future that restriction shall be
   removed - either call shall be unfiltered. (cagney 1999-06-13). */
extern struct ui_file *gdb_stdlog;
/* Target output that should bypass normal stdout/stderr filtering.
   For moment, always call this stream using *_unfiltered. In the
   very near future that restriction shall be removed - either call
   shall be unfiltered. (cagney 1999-07-02). */
extern struct ui_file *gdb_stdtarg;
extern struct ui_file *gdb_stdtargerr;
extern struct ui_file *gdb_stdtargin;
/* APPLE LOCAL gdb_null */
extern struct ui_file *gdb_null;

#include "ui-file.h"

/* More generic printf like operations.  Filtered versions may return
   non-locally on error.  */

extern void fputs_filtered(const char *, struct ui_file *);

extern void fputs_unfiltered(const char *, struct ui_file *);

extern int fputc_filtered(int c, struct ui_file *);

extern int fputc_unfiltered(int c, struct ui_file *);

extern int putchar_filtered(int c);

extern int putchar_unfiltered(int c);

extern void puts_filtered(const char *);

extern void puts_unfiltered(const char *);

extern void puts_filtered_tabular(char *string, int width, int right);

extern void puts_debug(const char *prefix, const char *string,
		       const char *suffix);

extern void vprintf_filtered(const char *, va_list)
  ATTR_FORMAT(printf, 1, 0);

extern void vfprintf_filtered(struct ui_file *, const char *, va_list)
  ATTR_FORMAT(gnu_printf, 2, 0);

extern void fprintf_filtered(struct ui_file *, const char *, ...)
  ATTR_FORMAT(gnu_printf, 2, 3);

extern void fprintfi_filtered(int, struct ui_file *, const char *, ...)
  ATTR_FORMAT(printf, 3, 4);

extern void printf_filtered(const char *, ...) ATTR_FORMAT(printf, 1, 2);

extern void printfi_filtered(int, const char *, ...)
  ATTR_FORMAT(printf, 2, 3);

extern void vprintf_unfiltered(const char *, va_list)
  ATTR_FORMAT(printf, 1, 0);

extern void vfprintf_unfiltered(struct ui_file *, const char *, va_list)
  ATTR_FORMAT(printf, 2, 0);

extern void fprintf_unfiltered(struct ui_file *, const char *, ...)
  ATTR_FORMAT(printf, 2, 3);

extern void printf_unfiltered(const char *, ...) ATTR_FORMAT(printf, 1, 2);

extern void print_spaces(int, struct ui_file *);

extern void print_spaces_filtered(int, struct ui_file *);

extern char *n_spaces(int);

extern void fputstr_filtered(const char *str, int quotr,
                             struct ui_file *stream);

extern void fputstr_unfiltered(const char *str, int quotr,
                               struct ui_file *stream);

extern void fputstrn_unfiltered(const char *str, int n, int quotr,
                                struct ui_file *stream);

/* Display the host ADDR on STREAM formatted as ``0x%x''. */
extern void gdb_print_host_address(const void *addr, struct ui_file *stream);

/* Convert a CORE_ADDR into a HEX string.  paddr() is like %08lx.
   paddr_nz() is like %lx.  paddr_u() is like %lu. paddr_width() is
   for ``%*''. */
extern int strlen_paddr(void);
extern char *paddr(CORE_ADDR addr);
extern char *paddr_nz(CORE_ADDR addr);
extern char *paddr_u(CORE_ADDR addr);
extern char *paddr_d(LONGEST addr);

/* Like 0x%lx, replaces deprecated_print_address_numeric: */
extern const char *paddress(CORE_ADDR addr);

struct gdbarch; /* forward declaration for next prototype */

/* Convert CORE_ADDR to string in platform-specific manner.
 * This is usually formatted similar to 0x%lx.  */
extern const char *paddress_with_arch(struct gdbarch *gdbarch, CORE_ADDR addr);

extern char *phex(ULONGEST l, int sizeof_l);
extern char *phex_nz(ULONGEST l, int sizeof_l);
extern char *int_string(LONGEST, int, int, int8_t, int);

/* Like paddr() only print/scan raw CORE_ADDR.  The output from
   core_addr_to_string() can be passed direct to
   string_to_core_addr().  */
extern const char *core_addr_to_string(const CORE_ADDR addr);
extern const char *core_addr_to_string_nz(const CORE_ADDR addr);
extern CORE_ADDR string_to_core_addr(const char *my_string);

/* Return a string that contains a number formatted as a hex
   string.  */
extern char *hex_string(LONGEST);
extern char *hex_string_custom(LONGEST, int);

extern void fprintf_symbol_filtered(struct ui_file *, const char *,
				    enum language, int);

extern NORETURN void perror_with_name(const char *)
  ATTR_NORETURN ATTRIBUTE_NOINLINE;

extern void print_sys_errmsg(const char *, int);

/* From symfile.c */

extern void symbol_file_command(const char *, int);

/* Remote targets may wish to use this as their load function: */
extern void generic_load(const char *name, int from_tty);

/* Summarise a download */
struct timeval;
extern void print_transfer_performance(struct ui_file *stream,
                                       unsigned long data_count,
                                       unsigned long write_count,
                                       const struct timeval *start_time,
                                       const struct timeval *end_time);

/* From top.c */

typedef void initialize_file_ftype(void);

extern char *skip_quoted(const char *);

extern char *gdb_readline(char *);

extern char *gdb_readline_wrapper(char *);

extern char *command_line_input(const char *, int, const char *);

extern void print_prompt(void);

extern int input_from_terminal_p(void);

extern int info_verbose;

/* APPLE LOCAL gdb_quitting */
extern int gdb_quitting;

/* From printcmd.c */

extern void set_next_address (CORE_ADDR);

extern void print_address_symbolic(CORE_ADDR, struct ui_file *, int,
				   const char *);

extern int build_address_symbolic(CORE_ADDR addr, int do_demangle,
				  char **name, int *offset,
                                  char **filename, int *line,
                                  int *unmapped);

extern void deprecated_print_address_numeric(CORE_ADDR, int,
                                             struct ui_file *)
  ATTRIBUTE_DEPRECATED_FOR(paddress);

extern void print_address(CORE_ADDR, struct ui_file *);

/* From source.c */

#define OPF_TRY_CWD_FIRST     0x01
#define OPF_SEARCH_IN_PATH    0x02

extern int openp(const char *, int, const char *, int, int, char **);

extern int source_full_path_of(char *, char **);

extern void mod_path(const char *, char **);

extern void add_path(const char *, char **, int);

extern void directory_command(const char *, int);

extern char *source_path;

extern void init_source_path(void);

extern void init_last_source_visited(void);

/* From exec.c */

extern void exec_set_section_offsets(bfd_signed_vma text_off,
				     bfd_signed_vma data_off,
				     bfd_signed_vma bss_off);

/* Take over the 'find_mapped_memory' vector from exec.c. */
extern void exec_set_find_memory_regions(int (*)(int (*)(CORE_ADDR,
                                                         unsigned long,
                                                         int, int, int,
                                                         void *),
                                                 void *));

/* Possible lvalue types.  Like enum language, this should be in
   value.h, but needs to be here for the same reason. */

enum lval_type
  {
    /* Not an lval. */
    not_lval,
    /* In memory.  */
    lval_memory,
    /* In a register.  Registers are relative to a frame.  */
    lval_register,
    /* APPLE LOCAL begin literal register setting */
    /* In a register, specified directly by name.  */
    lval_register_literal,
    /* APPLE LOCAL end literal register setting */
    /* In a gdb internal variable.  */
    lval_internalvar,
    /* Part of a gdb internal variable (structure field).  */
    lval_internalvar_component
  };

/* Control types for commands */

enum misc_command_type
  {
    ok_command,
    end_command,
    else_command,
    nop_command
  };

enum command_control_type
  {
    simple_control,
    break_control,
    continue_control,
    while_control,
    if_control,
    commands_control,
    invalid_control
  };

/* Structure for saved commands lines
   (for breakpoints, defined commands, etc).  */

struct command_line
  {
    struct command_line *next;
    char *line;
    enum command_control_type control_type;
    int body_count;
    struct command_line **body_list;
  };

/* APPLE LOCAL: Break out the read_command_lines from Readline,
   so you can read command lines directly from the MI.  */

extern struct command_line *read_command_lines(char *, int);
extern struct command_line *read_command_lines_1(char *(*read_next_line_func)(void));

extern void free_command_lines(struct command_line **);

/* To continue the execution commands when running gdb asynchronously.
   A continuation structure contains a pointer to a function to be called
   to finish the command, once the target has stopped. Such mechanism is
   used bt the finish and until commands, and in the remote protocol
   when opening an extended-remote connection. */

struct continuation_arg
  {
    struct continuation_arg *next;
    union continuation_data {
      void *pointer;
      int   integer;
      long  longint;
    } data;
  };

struct continuation
  {
    void (*continuation_hook)(struct continuation_arg *);
    struct continuation_arg *arg_list;
    struct continuation *next;
  };

/* In infrun.c. */
extern struct continuation *cmd_continuation;
/* Used only by the step_1 function. */
extern struct continuation *intermediate_continuation;

/* From utils.c */
extern void add_continuation(void (*)(struct continuation_arg *),
			     struct continuation_arg *);
extern void do_all_continuations(void);
extern void discard_all_continuations(void);

extern void add_intermediate_continuation(void (*)(struct continuation_arg *),
                                          struct continuation_arg *);
extern void do_all_intermediate_continuations(void);
extern void discard_all_intermediate_continuations(void);

/* String containing the current directory (what getwd would return).  */

extern char *current_directory;

/* Default radixes for input and output.  Only some values supported.  */
extern unsigned input_radix;
extern unsigned output_radix;

/* Possibilities for prettyprint parameters to routines which print
   things.  Like enum language, this should be in value.h, but needs
   to be here for the same reason.  FIXME:  If we can eliminate this
   as an arg to LA_VAL_PRINT, then we can probably move it back to
   value.h. */

enum val_prettyprint
  {
    Val_no_prettyprint = 0,
    Val_prettyprint,
    /* Use the default setting which the user has specified.  */
    Val_pretty_default
  };

/* The ptid struct is a collection of the various "ids" necessary
   for identifying the inferior.  This consists of the process id
   (pid), thread id (tid), and other fields necessary for uniquely
   identifying the inferior process/thread being debugged.  When
   manipulating ptids, the constructors, accessors, and predicate
   declared in inferior.h should be used.  These are as follows:

      ptid_build	- Make a new ptid from a pid, lwp, and tid.
      pid_to_ptid	- Make a new ptid from just a pid.
      ptid_get_pid	- Fetch the pid component of a ptid.
      ptid_get_lwp	- Fetch the lwp component of a ptid.
      ptid_get_tid	- Fetch the tid component of a ptid.
      ptid_equal	- Test to see if two ptids are equal.

   Please do NOT access the struct ptid members directly (except, of
   course, in the implementation of the above ptid manipulation
   functions).  */

struct ptid
  {
    /* Process id */
    int pid;

    /* Lightweight process id */
    long lwp;

    /* Thread id */
    long tid;
  };

typedef struct ptid ptid_t;

/* APPLE LOCAL begin scheduler locking */
/* infrun.c controls the scheduler locking, but other parts of the
   code may need to swap the mode for their own purposes.  These
   functions allow you to do so. */

enum scheduler_locking_mode {
  scheduler_locking_off = 0,
  scheduler_locking_on = 1,
  scheduler_locking_step = 2
};

extern enum scheduler_locking_mode
  set_scheduler_locking_mode(enum scheduler_locking_mode new_mode);
extern void scheduler_run_this_ptid(struct ptid this_ptid);
extern int scheduler_lock_on_p(void);
extern struct ptid get_scheduler_lock_ptid(void);
extern struct cleanup *
  make_cleanup_set_restore_scheduler_locking_mode(enum scheduler_locking_mode);
/* APPLE LOCAL end scheduler locking */

extern uint8_t **get_binary_file_uuids(const char *filename);

extern void free_uuids_array(uint8_t **uuids);

extern char *puuid(uint8_t *uuid);

extern const char *re_comp(const char *str);

extern int re_exec(const char *str);

#if !(defined(_REGEX_H) && (defined(_GNU_SOURCE) || defined(__USE_GNU)))
extern int re_set_syntax(int newflags);
#endif /* !(_REGEX_H && (_GNU_SOURCE || __USE_GNU)) */

extern int re_search_oneshot(regex_t *patbuf, const char *str, size_t size,
			     int start, size_t range, void *regs);

#ifndef REG_BASIC
# if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
#  define	REG_BASIC	0000
# endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
#endif /* !REG_BASIC */


/* List of known OS ABIs.  If you change this, make sure to update the
 * table in osabi.c.  */
enum gdb_osabi
{
  GDB_OSABI_UNINITIALIZED = -1, /* For struct gdbarch_info.  */

  GDB_OSABI_UNKNOWN = 0,	/* keep this zero */

  GDB_OSABI_SVR4 = 1,
  GDB_OSABI_HURD = 2,
  GDB_OSABI_SOLARIS = 3,
  GDB_OSABI_OSF1 = 4,
  GDB_OSABI_LINUX = 5,
  GDB_OSABI_FREEBSD_AOUT = 6,
  GDB_OSABI_FREEBSD_ELF = 7,
  GDB_OSABI_NETBSD_AOUT = 8,
  GDB_OSABI_NETBSD_ELF = 9,
  GDB_OSABI_OPENBSD_ELF = 10,
  GDB_OSABI_WINCE = 11,
  GDB_OSABI_GO32 = 12,
  GDB_OSABI_NETWARE = 13,
  GDB_OSABI_IRIX = 14,
  GDB_OSABI_LYNXOS = 15,
  GDB_OSABI_INTERIX = 16,
  GDB_OSABI_HPUX_ELF = 17,
  GDB_OSABI_HPUX_SOM = 18,
  /* APPLE LOCAL begin Darwin */
  GDB_OSABI_DARWIN = 19,
  GDB_OSABI_DARWIN64 = 20,
  GDB_OSABI_DARWINV6 = 21,
  GDB_OSABI_DARWINV7 = 22,
  GDB_OSABI_DARWINV7F = 23,
  GDB_OSABI_DARWINV7S = 24,
  GDB_OSABI_DARWINV7K = 25,
  /* APPLE LOCAL end Darwin */

  GDB_OSABI_QNXNTO = 26,

  GDB_OSABI_CYGWIN = 27,

  GDB_OSABI_AIX = 28,
  GDB_OSABI_DICOS = 29,
  GDB_OSABI_SYMBIAN = 30,
#ifdef ENUMS_CAN_BE_LONG
  GDB_OSABI_OPENVMS,
  GDB_OSABI_LYNXOS178,
  GDB_OSABI_NEWLIB,
  GDB_OSABI_SDE,
#endif /* ENUMS_CAN_BE_LONG */

  GDB_OSABI_INVALID		/* keep this last */
};

/* APPLE LOCAL gdb_client_data */
/* Typedef for anonymous data type for event data: */
typedef void *gdb_client_data;

/* Optional host machine definition. Pure autoconf targets will not
   need a "xm.h" file. This will be a symlink to one of the xm-*.h
   files, built by the `configure' script.  */

#ifdef GDB_XM_FILE
# include "xm.h"
#endif /* GDB_XM_FILE */

/* Optional native machine support.  Non-native (and possibly pure
   multi-arch) targets do not need a "nm.h" file.  This will be a
   symlink to one of the nm-*.h files, built by the `configure'
   script.  */

#ifdef GDB_NM_FILE
# include "nm.h"
#endif /* GDB_NM_FILE */

/* Optional target machine definition.  Pure multi-arch configurations
   do not need a "tm.h" file.  This will be a symlink to one of the
   tm-*.h files, built by the `configure' script.  */

#ifdef GDB_TM_FILE
# include "tm.h"
#endif /* GDB_TM_FILE */

/* Assume that fopen accepts the letter "b" in the mode string.
   It is demanded by ISO C9X, and should be supported on all
   platforms that claim to have a standard-conforming C library.  On
   true POSIX systems it will be ignored and have no effect.  There
   may still be systems without a standard-conforming C library where
   an ISO C9X compiler (GCC) is available.  Known examples are SunOS
   4.x and 4.3BSD.  This assumption means these systems are no longer
   supported.  */
#ifndef FOPEN_RB
# include "fopen-bin.h"
#endif /* !FOPEN_RB */

/* Defaults for system-wide constants (if not defined by xm.h, we fake it).
   FIXME: Assumes 2's complement arithmetic */

#if !defined(UINT_MAX)
# define UINT_MAX ((unsigned int)(~0))	/* 0xFFFFFFFF for 32-bits */
#endif /* !UINT_MAX */

#if !defined(INT_MAX)
# define INT_MAX ((int)(UINT_MAX >> 1))	/* 0x7FFFFFFF for 32-bits */
#endif /* !INT_MAX */

#if !defined(INT_MIN)
# define INT_MIN ((int)((int) ~0 ^ INT_MAX)) /* 0x80000000 for 32-bits */
#endif /* !INT_MIN */

#if !defined (ULONG_MAX)
# define ULONG_MAX ((unsigned long)(~0L)) /* 0xFFFFFFFF for 32-bits */
#endif /* !ULONG_MAX */

#if !defined(LONG_MAX)
# define LONG_MAX ((long)(ULONG_MAX >> 1L)) /* 0x7FFFFFFF for 32-bits */
#endif /* !LONG_MAX */

#if !defined (ULONGEST_MAX)
# define ULONGEST_MAX (~(ULONGEST)0UL) /* 0xFFFFFFFFFFFFFFFF for 64-bits */
#endif /* !ULONGEST_MAX */

#if !defined(LONGEST_MAX)             /* 0x7FFFFFFFFFFFFFFF for 64-bits */
# define LONGEST_MAX ((LONGEST)(ULONGEST_MAX >> 1L))
#endif /* !LONGEST_MAX */

/* Convert a LONGEST to an int.  This is used in contexts (e.g. number of
   arguments to a function, number in a value history, register number, etc.)
   where the value must not be larger than can fit in an int.  */

extern int longest_to_int(LONGEST)
  ATTRIBUTE_W_U_R;

/* Assorted functions we can declare, now that const and volatile are
   defined.  */

extern char *savestring(const char *, size_t)
  ATTRIBUTE_W_U_R;

/* APPLE LOCAL begin mmalloc */
extern char *msavestring(void *, const char *, size_t)
  ATTRIBUTE_W_U_R;

extern char *strsave(const char *ptr)
  ATTRIBUTE_W_U_R ATTRIBUTE_DEPRECATED;

extern char *mstrsave(void *, const char *)
  ATTRIBUTE_W_U_R;

/* Robust versions of same.  Throw an internal error when no memory,
   guard against stray NULL arguments. */
extern void *xmmalloc(void *md, size_t size)
  ATTRIBUTE_W_U_R ATTRIBUTE_MALLOC;
extern void *xmrealloc(void *md, void *ptr, size_t size)
  ATTRIBUTE_W_U_R ATTRIBUTE_MALLOC;
extern void *xmcalloc(void *md, size_t number, size_t size)
  ATTRIBUTE_W_U_R ATTRIBUTE_MALLOC;
extern void xmfree(void *md, void *ptr);
/* APPLE LOCAL end mmalloc */

#ifndef LIBIBERTY_H
/* xmalloc(), xrealloc() and xcalloc() have already been declared in
   "libiberty.h". */
extern void xfree(void *);
#endif /* !LIBIBERTY_H */

/* Like xmalloc, but zero the memory.  */
extern void *xzalloc(size_t)
  ATTRIBUTE_W_U_R ATTRIBUTE_MALLOC;

/* Utility macros to allocate typed memory.  Avoids errors like:
   struct foo *foo = xmalloc (sizeof struct bar); and memset (foo,
   sizeof (struct foo), 0).  */
#define XZALLOC(TYPE) ((TYPE*)xzalloc(sizeof(TYPE)))
#define XMALLOC(TYPE) ((TYPE*)xmalloc(sizeof(TYPE)))
#define XCALLOC(NMEMB, TYPE) ((TYPE*)xcalloc((NMEMB), sizeof(TYPE)))


/* Like asprintf/vasprintf but get an internal_error if the call fails: */
extern void xasprintf(char **ret, const char *format, ...)
     ATTR_FORMAT(printf, 2, 3);
#ifndef LIBIBERTY_H
extern void xvasprintf(char **ret, const char *format, va_list ap)
     ATTR_FORMAT(printf, 2, 0);
#endif /* !LIBIBERTY_H */

/* Like asprintf and vasprintf, but return the string, throw an error
   if no memory.  */
extern char *xstrprintf(const char *format, ...) ATTR_FORMAT(printf, 1, 2)
     ATTRIBUTE_W_U_R;
extern char *xstrvprintf(const char *format, va_list ap)
     ATTR_FORMAT(gnu_printf, 1, 0) ATTRIBUTE_W_U_R;

/* Like snprintf, but throw an error if the output buffer is too small.  */
extern int xsnprintf(char *str, size_t size, const char *format, ...)
     ATTR_FORMAT(printf, 3, 4);

extern int parse_escape(const char **);

/* Message to be printed before the error message, when an error occurs: */
extern const char *error_pre_print;

/* Message to be printed before the error message, when an error occurs: */
extern const char *quit_pre_print;

/* Message to be printed before the warning message, when a warning occurs: */
extern const char *warning_pre_print;

extern NORETURN void verror(const char *fmt, va_list ap)
     ATTR_NORETURN ATTR_FORMAT(printf, 1, 0);

extern NORETURN void error(const char *fmt, ...) ATTR_NORETURN ATTR_FORMAT(printf, 1, 2);

extern NORETURN void error_stream(struct ui_file *) ATTR_NORETURN;

extern NORETURN void vfatal(const char *fmt, va_list ap)
     ATTR_NORETURN ATTR_FORMAT(printf, 1, 0);

extern NORETURN void fatal(const char *fmt, ...) ATTR_NORETURN ATTR_FORMAT(printf, 1, 2);

extern NORETURN void internal_verror(const char *file, int line,
				     const char *, va_list ap)
     ATTR_NORETURN ATTR_FORMAT(printf, 3, 0);

extern NORETURN void internal_error(const char *file, int line,
				    const char *, ...) ATTR_NORETURN ATTR_FORMAT(printf, 3, 4);

extern void internal_vwarning(const char *file, int line,
			      const char *, va_list ap)
     ATTR_FORMAT(printf, 3, 0);

extern void internal_warning(const char *file, int line,
			     const char *, ...) ATTR_FORMAT(printf, 3, 4);

extern NORETURN void nomem(long) ATTR_NORETURN;

extern void warning(const char *, ...) ATTR_FORMAT(printf, 1, 2);

extern void vwarning(const char *, va_list args) ATTR_FORMAT(printf, 1, 0);

/* The enum that was here has been moved higher above. */

/* Global functions from other, non-gdb GNU thingies.
 * Libiberty thingies are no longer declared here. We include libiberty.h
 * above, instead. */

/* From other system libraries: */

/* should have already been included above... can probably remove this: */
#if defined(HAVE_STDDEF_H) || __has_include(<stddef.h>)
# include <stddef.h>
#else
# if defined(__GNUC__) && !defined(__STRICT_ANSI__) && !defined(__STDDEF_H__)
 #  warning "defs.h expects <stddef.h> to be included."
# endif /* __GNUC__ && !__STRICT_ANSI__ && !__STDDEF_H__ */
#endif /* HAVE_STDDEF_H */

#if defined(HAVE_STDLIB_H)  || defined(STDC_HEADERS) || defined(__STDC__) || \
    __has_include(<stdlib.h>)
# include <stdlib.h>
#else
# if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 #  warning "defs.h expects <stdlib.h> to be included."
# endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* HAVE_STDLIB_H || STDC_HEADERS || __STDC__ */

#ifndef min
# define min(a, b) ((a) < (b) ? (a) : (b))
#endif /* !min */

#ifndef max
# define max(a, b) ((a) > (b) ? (a) : (b))
#endif /* !max */


#if !defined(atof) && (!defined(HAVE_DECL_ATOF) || \
                       (defined(HAVE_DECL_ATOF) && !HAVE_DECL_ATOF))
extern double atof(const char *);	/* X3.159-1989  4.10.1.1 */
#endif /* !atof && !HAVE_DECL_ATOF */

#if !defined(_STRING_H_) || defined(S_SPLINT_S)
# if !defined(strlcat) && (!defined(HAVE_DECL_STRLCAT) || !HAVE_DECL_STRLCAT)
extern size_t strlcat(char *, const char *, size_t);
# endif /* !strlcat && !HAVE_DECL_STRLCAT */
# if !defined(strlcpy) && (!defined(HAVE_DECL_STRLCPY) || !HAVE_DECL_STRLCPY)
extern size_t strlcpy(char *, const char *, size_t);
# endif /* !strlcpy && !HAVE_DECL_STRLCPY */
#endif /* !_STRING_H_ || S_SPLINT_S */

#if !defined(_STRINGS_H_) || defined(S_SPLINT_S)
# if !defined(bcopy) && (!defined(HAVE_DECL_BCOPY) || !HAVE_DECL_BCOPY)
extern void bcopy(const void *, void *, size_t);
# endif /* !bcopy && !HAVE_DECL_BCOPY */
# if !defined(bzero) && (!defined(HAVE_DECL_BZERO) || !HAVE_DECL_BZERO)
extern void bzero(void *, size_t);
# endif /* !bzero && !HAVE_DECL_BZERO */
# if !defined(strcasecmp) && (!defined(HAVE_DECL_STRCASECMP) || !HAVE_DECL_STRCASECMP)
extern int strcasecmp(const char *, const char *);
# endif /* !strcasecmp && !HAVE_DECL_STRCASECMP */
# if !defined(strncasecmp) && (!defined(HAVE_DECL_STRNCASECMP) || !HAVE_DECL_STRNCASECMP)
extern int strncasecmp(const char *, const char *, size_t);
# endif /* !strncasecmp && !HAVE_DECL_STRNCASECMP */
#endif /* !_STRINGS_H_ || S_SPLINT_S */

#if !defined(_STDLIB_H_) || defined(S_SPLINT_S)
# if !defined(qsort_r) && (!defined(HAVE_DECL_QSORT_R) || !HAVE_DECL_QSORT_R)
extern void qsort_r(void *, size_t, size_t, void *,
		    int (*)(void *, const void *, const void *));
# endif /* !qsort_r && !HAVE_DECL_QSORT_R */
# if !defined(realpath) && (!defined(HAVE_DECL_REALPATH) || !HAVE_DECL_REALPATH)
extern char *realpath(const char *restrict, char *restrict);
# endif /* !realpath && !HAVE_DECL_REALPATH */
#endif /* !_STDLIB_H_ || S_SPLINT_S */

#if !defined(_SYS_TIME_H_) || defined(S_SPLINT_S)
# if !defined(gettimeofday) && (!defined(HAVE_DECL_GETTIMEOFDAY) || !HAVE_DECL_GETTIMEOFDAY)
extern int gettimeofday(struct timeval *restrict, void *restrict);
# endif /* !gettimeofday && !HAVE_DECL_GETTIMEOFDAY */
# if !defined(setitimer) && (!defined(HAVE_DECL_SETITIMER) || !HAVE_DECL_SETITIMER)
extern int setitimer(int, const struct itimerval *restrict,
		     struct itimerval *restrict);
# endif /* !setititmer && !HAVE_DECL_SETITIMER */
#endif /* !_SYS_TIME_H_ || S_SPLINT_S */

#if !defined(_TIME_H_) || defined(S_SPLINT_S)
# if !defined(gmtime) && (!defined(HAVE_DECL_GMTIME) || !HAVE_DECL_GMTIME)
extern struct tm *gmtime(const time_t *);
# endif /* !gmtime && !HAVE_DECL_GMTIME */
# if !defined(localtime) && (!defined(HAVE_DECL_LOCALTIME) || !HAVE_DECL_LOCALTIME)
extern struct tm *localtime(const time_t *);
# endif /* !localtime && !HAVE_DECL_LOCALTIME */
# if !defined(localtime_r) && (!defined(HAVE_DECL_LOCALTIME_R) || !HAVE_DECL_LOCALTIME_R)
extern struct tm *localtime_r(const time_t *restrict, struct tm *restrict);
# endif /* !localtime_r && !HAVE_DECL_LOCALTIME_R */
#endif /* !_TIME_H_ || S_SPLINT_S */

#if defined(HAVE_GETCWD) && (!defined(HAVE_DECL_GETCWD) || !HAVE_DECL_GETCWD)
extern char *getcwd(char *, size_t) ATTRIBUTE_W_U_R;
#endif /* HAVE_GETCWD && !HAVE_DECL_GETCWD */

/* Various possibilities for alloca: */
#ifndef alloca
# ifdef __GNUC__
#  define alloca __builtin_alloca
# else /* Not GNU C */
#  if defined(HAVE_ALLOCA_H) || __has_include(<alloca.h>)
#   include <alloca.h>
#  else
#   ifdef _AIX
 #    pragma alloca
#   else
/* We need to be careful not to declare this in a way which conflicts with
   bison. Bison never declares it as char *, but under various circumstances
   (like __hpux) we need to use void *.  */
extern void *alloca(void);
#   endif /* Not _AIX */
#  endif /* Not HAVE_ALLOCA_H */
# endif /* Not GNU C */
#endif /* alloca not defined */

/* Dynamic target-system-dependent parameters for GDB: */
#include "gdbarch.h"

/* Maximum size of a register.  Something small, but large enough for
   all known ISAs.  If it turns out to be too small, make it bigger.  */

enum { MAX_REGISTER_SIZE = 16 };

/* Static target-system-dependent parameters for GDB. */

/* Number of bits in a char or unsigned char for the target machine.
   Just like CHAR_BIT in <limits.h> but describes the target machine.  */
#if !defined(TARGET_CHAR_BIT)
# define TARGET_CHAR_BIT 8U
#endif /* !TARGET_CHAR_BIT */

/* If we picked up a copy of CHAR_BIT from a configuration file
   (which may get it by including <limits.h>) then use it to set
   the number of bits in a host char.  If not, use the same size
   as the target. */

#if defined(CHAR_BIT)
# define HOST_CHAR_BIT CHAR_BIT
#else
# define HOST_CHAR_BIT TARGET_CHAR_BIT
#endif /* CHAR_BIT */

/* The bit byte-order has to do just with numbering of bits in
   debugging symbols and such.  Conceptually, it's quite separate
   from byte/word byte order.  */

#if !defined (BITS_BIG_ENDIAN)
# define BITS_BIG_ENDIAN (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
#endif /* !BITS_BIG_ENDIAN */

/* In findvar.c.  */

extern LONGEST extract_signed_integer(const gdb_byte *, int);

/* APPLE LOCAL explicit byte order */
extern LONGEST extract_signed_integer_with_byte_order(const gdb_byte *, int, int);

extern ULONGEST extract_unsigned_integer(const gdb_byte *, int);

/* APPLE LOCAL explicit byte order */
extern ULONGEST extract_unsigned_integer_with_byte_order(const gdb_byte *, int, int);

extern int extract_long_unsigned_integer(const gdb_byte *, int, LONGEST *);

/* APPLE LOCAL explicit byte order */
extern int extract_long_unsigned_integer_with_byte_order(const gdb_byte *, int, LONGEST *, int);

extern CORE_ADDR extract_typed_address(const gdb_byte *buf,
                                       struct type *type) ATTRIBUTE_W_U_R;

extern void store_signed_integer(gdb_byte *, int, LONGEST);

/* APPLE LOCAL explicit byte order */
extern void store_signed_integer_with_byte_order(gdb_byte *, int, LONGEST, int);

extern void store_unsigned_integer(gdb_byte *, int, ULONGEST);

/* APPLE LOCAL explicit byte order */
extern void store_unsigned_integer_with_byte_order(gdb_byte *, int, ULONGEST, int);

extern void store_typed_address(gdb_byte *buf, struct type *type,
                                CORE_ADDR addr);

/* From valops.c */

extern int watchdog;

/* Hooks for alternate command interfaces.  */

/* The name of the interpreter if specified on the command line: */
extern char *interpreter_p;

/* If a given interpreter matches INTERPRETER_P then it should update
   deprecated_command_loop_hook and deprecated_init_ui_hook with the
   per-interpreter implementation.  */
/* FIXME: deprecated_command_loop_hook and deprecated_init_ui_hook
   should be moved here. */

struct target_waitstatus;
struct cmd_list_element;

/* gdb_client_data definition moved earlier */

/* APPLE LOCAL Debugger_state */
typedef enum {
  STATE_NOT_ACTIVE,
  STATE_ACTIVE,
  STATE_INFERIOR_LOADED,
  STATE_INFERIOR_EXITED,
  STATE_INFERIOR_LOGICALLY_RUNNING,
  STATE_INFERIOR_STOPPED
} Debugger_state;

/* APPLE LOCAL begin hooks */
extern void (*init_ui_hook)(char *argv0);
extern void (*command_loop_hook)(void);
/* APPLE LOCAL end hooks */
extern void (*deprecated_pre_add_symbol_hook)(const char *)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_post_add_symbol_hook)(void)
  ATTRIBUTE_DEPRECATED;
extern void (*selected_frame_level_changed_hook)(int)
  ATTRIBUTE_DEPRECATED;
extern int (*deprecated_ui_loop_hook)(int signo)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_init_ui_hook)(char *argv0)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_command_loop_hook)(void)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_show_load_progress)(const char *section,
					     unsigned long section_sent,
					     unsigned long section_size,
					     unsigned long total_sent,
					     unsigned long total_size)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_print_frame_info_listing_hook)(struct symtab * s,
                                                        int line, int stopline,
                                                        int noerror)
  ATTRIBUTE_DEPRECATED;
/* APPLE LOCAL begin hooks */
extern void (*print_frame_more_info_hook)(struct ui_out *uiout,
                                          struct symtab_and_line *sal,
                                          struct frame_info *fi);
/* APPLE LOCAL end hooks */

/* APPLE LOCAL begin hooks */
/* called in place of printing a source line */
extern void (*print_source_lines_hook)
     (struct symtab *s, int line, int stopline);

/* called when the state of the debugger (i.e. gdb) changes */
extern void (*state_change_hook)(Debugger_state new_state);

/* called when the frame changes (e.g. as the result of "up") */
extern void (*frame_changed_hook)(int new_frame_number);

/* called when the stack changes (i.e. a new frame is added) */
extern void (*stack_changed_hook)(void);

/* called when command line input is needed: */
extern char *(*command_line_input_hook)(const char *, int, const char *);

/* these <command>_hooks are called after the command has processed its arguments
   and just before it calls out to do the work of the command */
/* called when a stepping command (step, next, stepi, nexti) is issued */
extern void (*stepping_command_hook)(void);
/* APPLE LOCAL end hooks */

extern int (*deprecated_query_hook)(const char *, va_list)
     ATTRIBUTE_FPTR_PRINTF(1,0) ATTRIBUTE_DEPRECATED;
extern void (*deprecated_warning_hook)(const char *, va_list)
     ATTRIBUTE_FPTR_PRINTF(1,0) ATTRIBUTE_DEPRECATED;

extern void (*deprecated_flush_hook)(struct ui_file * stream)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_create_breakpoint_hook)(struct breakpoint * b)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_delete_breakpoint_hook)(struct breakpoint * bpt)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_modify_breakpoint_hook)(struct breakpoint * bpt)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_interactive_hook)(void)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_registers_changed_hook)(void)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_readline_begin_hook)(const char *, ...)
     ATTRIBUTE_FPTR_PRINTF_1 ATTRIBUTE_DEPRECATED;
extern char *(*deprecated_readline_hook)(char *)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_readline_end_hook)(void)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_register_changed_hook)(int regno)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_memory_changed_hook)(CORE_ADDR addr, int len)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_context_hook)(int)
  ATTRIBUTE_DEPRECATED;
extern ptid_t (*deprecated_target_wait_hook)(ptid_t ptid,
					     /* APPLE LOCAL target wait hook */
					     struct target_waitstatus * status,
					     gdb_client_data client_data)
  ATTRIBUTE_DEPRECATED;

extern void (*deprecated_attach_hook)(void)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_detach_hook)(void)
  ATTRIBUTE_DEPRECATED;
extern void (*deprecated_call_command_hook)(struct cmd_list_element * c,
					    const char *cmd, int from_tty)
  ATTRIBUTE_DEPRECATED;

extern void (*deprecated_set_hook)(struct cmd_list_element *c)
  ATTRIBUTE_DEPRECATED;

extern void (*deprecated_error_hook)(void)
  ATTRIBUTE_DEPRECATED;

/* APPLE LOCAL begin hooks */
/* called when the continue command is issued: */
extern void (*continue_command_hook)(void);
/* APPLE LOCAL end hooks */

extern void (*deprecated_error_begin_hook)(void)
  ATTRIBUTE_DEPRECATED;

/* APPLE LOCAL begin hooks */
/* called when the run command is issued;
 * return 1 means do the run; 0 means do not: */
extern int (*run_command_hook)(void) ATTRIBUTE_W_U_R;
extern void (*hand_call_function_hook)(void);
/* APPLE LOCAL end hooks */

extern int (*deprecated_ui_load_progress_hook)(const char *section,
                                               unsigned long num)
  ATTRIBUTE_DEPRECATED;


/* Inhibit window interface if non-zero: */
extern int use_windows;

/* Symbolic definitions of filename-related things.  */
/* FIXME, this doesn't work very well if host and executable
   filesystems conventions are different.  */

#ifdef __MSDOS__
# define CANT_FORK
# define GLOBAL_CURDIR
# define DIRNAME_SEPARATOR ';'
#endif /* __MSDOS__ */

#ifndef DIRNAME_SEPARATOR
# define DIRNAME_SEPARATOR ':'
#endif /* !DIRNAME_SEPARATOR */

#ifndef SLASH_STRING
# define SLASH_STRING "/"
#endif /* !SLASH_STRING */

/* Provide default definitions of PIDGET, TIDGET, and MERGEPID.
   The name ``TIDGET'' is a historical accident. Many uses of TIDGET
   in the code actually refer to a lightweight process id, i.e,
   something that can be considered a process id in its own right for
   certain purposes.  */

#ifndef PIDGET
# define PIDGET(PTID) (ptid_get_pid(PTID))
# define TIDGET(PTID) (ptid_get_lwp(PTID))
# define MERGEPID(PID, TID) ptid_build(PID, TID, 0)
#endif /* !PIDGET */

/* Define well known filenos if the system does not define them: */
#ifndef STDIN_FILENO
# define STDIN_FILENO   0
#endif /* !STDIN_FILENO */
#ifndef STDOUT_FILENO
# define STDOUT_FILENO  1
#endif /* STDOUT_FILENO */
#ifndef STDERR_FILENO
# define STDERR_FILENO  2
#endif /* !STDERR_FILENO */

/* If this definition is NOT overridden by the header files, assume
   that isatty and fileno exist on this system.  */
#ifndef ISATTY
# define ISATTY(FP)	(isatty(fileno(FP)))
#endif /* !ISATTY */

/* Ensure that V is aligned to an N byte boundary (B's assumed to be a
   power of 2).  Round up/down when necessary.  Examples of correct
   use include:

   addr = align_up (addr, 8); -- VALUE needs 8 byte alignment
   write_memory (addr, value, len);
   addr += len;

   and:

   sp = align_down (sp - len, 16); -- Keep SP 16 byte aligned
   write_memory (sp, value, len);

   Note that uses such as:

   write_memory (addr, value, len);
   addr += align_up (len, 8);

   and:

   sp -= align_up (len, 8);
   write_memory (sp, value, len);

   are typically not correct as they don't ensure that the address (SP
   or ADDR) is correctly aligned (relying on previous alignment to
   keep things right).  This is also why the methods are called
   "align_..." instead of "round_..." as the latter reads better with
   this incorrect coding style.  */

extern ULONGEST align_up(ULONGEST v, int n) ATTRIBUTE_W_U_R;
extern ULONGEST align_down(ULONGEST v, int n) ATTRIBUTE_W_U_R;

/* APPLE LOCAL: Make this public since fork-child.c and remote.c now use it: */
extern void breakup_args(char *scratch, int *argc, char **argv);

/* APPLE LOCAL begin CHECK macro: */
#define __CHECK_FUNCTION __extension__ __PRETTY_FUNCTION__

#if defined(__cplusplus) || defined(__STRICT_ANSI__)
# define CHECK(expression) \
   ((void)((expression) ? (void)0 : gdb_check(#expression, __FILE__, __LINE__, __CHECK_FUNCTION)))

# define CHECK_FATAL(expression) \
   ((void)((expression) ? (void)0 : gdb_check_fatal(#expression, __FILE__, __LINE__, __CHECK_FUNCTION)))
#else
# define CHECK(expression) \
   ((void)((expression) ? 0 : gdb_check(#expression, __FILE__, __LINE__, __CHECK_FUNCTION)))

# define CHECK_FATAL(expression) \
   ((void)((expression) ? 0 : gdb_check_fatal(#expression, __FILE__, __LINE__, __CHECK_FUNCTION)))
#endif /* __cplusplus || __STRICT_ANSI__ */

extern void ATTR_NORETURN gdb_check(const char *str, const char *file,
				    unsigned int line, const char *func);
extern void ATTR_NORETURN gdb_check_fatal(const char *str, const char *file,
					  unsigned int line, const char *func);
/* APPLE LOCAL end CHECK macro */

/* Use gdb_unreachable() to mark unreachable locations, like an
 * unreachable default case of a switch.  Do not use gdb_assert(0).  */
#if (GCC_VERSION >= 4005) && (!defined(ENABLE_ASSERT_CHECKING) || !ENABLE_ASSERT_CHECKING)
# define gdb_unreachable() __builtin_unreachable()
#else
# define gdb_unreachable() (gdb_check_fatal("unreachable location reached", __FILE__, __LINE__, __FUNCTION__))
#endif

/* APPLE LOCAL: Local timer stuff */
extern int maint_use_timers;
extern struct cleanup *start_timer(int *timer_var, const char *timer_name,
				   const char *this_mssg) ATTRIBUTE_W_U_R;

/* APPLE LOCAL: Used in target_check_safe_call:  */
#define MALLOC_SUBSYSTEM (1 << 0)
#define OBJC_SUBSYSTEM   (1 << 1)
#define LOADER_SUBSYSTEM (1 << 2)
#define SPINLOCK_SUBSYSTEM (1 << 3)
#define ALL_SUBSYSTEMS (MALLOC_SUBSYSTEM|OBJC_SUBSYSTEM|LOADER_SUBSYSTEM|SPINLOCK_SUBSYSTEM)

/* poison some unwanted functions: */
#if (defined(__GNUC__) && defined(__GNUC_MINOR__) && (__GNUC__ >= 3)) && \
    !defined(NO_POISON) && !defined(FLEX_SCANNER)
# ifndef DEFS_H_DOING_POISONING
#  define DEFS_H_DOING_POISONING 1
# endif /* !DEFS_H_DOING_POISONING */
# ifdef sprintf
#  undef sprintf
# endif /* sprintf */
# ifdef vsprintf
#  undef vsprintf
# endif /* vsprintf */
# ifdef strdup
#  undef strdup
# endif /* strdup */
# ifdef free
#  undef free
# endif /* free */
# ifdef bzero
#  undef bzero
# endif /* bzero */
# ifdef realloc
#  undef realloc
# endif /* realloc */
/* gdbint.texinfo says to avoid these ones: */
# pragma GCC poison malloc realloc calloc free strdup sprintf
/* for similar reasons, such as libiberty also providing replacements: */
# pragma GCC poison strndup memdup vsprintf vasprintf
# ifndef strerror
#  pragma GCC poison strerror
# endif /* !strerror */
/* also consider poisoining for similar reasons: asprintf atexit exit */
# if defined(HAVE_STRLCPY) && defined(PREFER_BSDISMS)
#  pragma GCC poison strcpy
# endif /* HAVE_STRLCPY && PREFER_BSDISMS */
# if defined(HAVE_STRLCAT) && defined(PREFER_BSDISMS)
#  pragma GCC poison strcat
# endif /* HAVE_STRLCAT && PREFER_BSDISMS */
# if defined(HAVE_FGETS)
#  pragma GCC poison gets
# endif /* HAVE_FGETS */
# if defined(HAVE_STRTOK_R) && defined(_REENTRANT)
#  pragma GCC poison strtok
# endif /* HAVE_STRTOK_R && _REENTRANT */
/* gdb_ari.sh says to avoid these: */
# pragma GCC poison setlinebuf bzero strnicmp
/* Newer macOS SDKs use bcmp in <netinet/in.h>; need to refine this condition
 * once I've found out which specifically: */
# ifndef HAVE_NETINET_IN_H
#  pragma GCC poison bcmp
# endif /* !HAVE_NETINET_IN_H */
/* also consider poisoning: assert abort basename bcopy strsave */
#endif /* gcc3+ && !NO_POISON && !FLEX_SCANNER */

#endif /* #ifndef DEFS_H */

/* EOF */
