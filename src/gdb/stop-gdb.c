/* stop-gdb.c: A client to make GDB return to command level in Mach 3.
 * Copyright 1992, 1993, 1994, 2000 Free Software Foundation, Inc.
 *
 * This file is part of GDB.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.  */

/* Authors: Jukka Virtanen <jtv@hut.fi> and Peter Stout <pds@cs.cmu.edu>.
 *
 * A simple client to make GDB (versions 4.4 and later) on Mach 3 return
 * to the command level when it is waiting for the inferior to stop.
 *
 * Actions: Lookup the send right to the GDB message port from the
 * NetMsgServer.
 *
 * Send an asynchronous message with msgh_id
 * GDB_MESSAGE_ID_STOP to that port.
 */

#if !defined(NO_POISON) && defined(POISON_FREE_TOO)
/* included files can drag in "free": */
# define NO_POISON 1
#endif /* !NO_POISON && POISON_FREE_TOO */

#include <stdio.h>

#include "defs.h"

#ifdef HAVE_MACH_H
# include <mach.h>
#else
# ifdef HAVE_MACH_MACH_H
#  include <mach/mach.h>
# else
#  if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#   warning "stop-gdb.c needs a mach C header to be included."
#  endif /* __GNUC__ && !__STRICT_ANSI__ */
# endif /* HAVE_MACH_MACH_H */
#endif /* HAVE_MACH_H */
#include <mach/message.h>
/* this is tricky, because autoconf could generate the following define from
 * either "<mach_error.h>" or "<mach/error.h>", both of which could actually be
 * names of C header files. We only check for the former in the configure script
 * currently though. */
#ifdef HAVE_MACH_ERROR_H
# include <mach_error.h>
#else
# ifdef HAVE_MACH_MACH_ERROR_H
#  include <mach/mach_error.h>
# else
#  if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#   warning "stop-gdb.c needs a mach_error C header to be included."
#  endif /* __GNUC__ && !__STRICT_ANSI__ */
# endif /* HAVE_MACH_MACH_ERROR_H */
#endif /* HAVE_MACH_ERROR_H */
#include <servers/netname.h>
#include <servers/netname_defs.h>

/* from "config/nm-m3.h": */
#ifndef GDB_MESSAGE_ID_STOP
/* If our_message_port gets a msg with this ID, GDB suspends its inferior,
 * and then enters command level. (Useful at least if ^C does not work) */
# define GDB_MESSAGE_ID_STOP 0x41151
#endif /* !GDB_MESSAGE_ID_STOP */

/* FIXME: these next 2 are arbitrarily chosen; not sure if correct: */
#ifndef GDB_DEF_NAME
# define GDB_DEF_NAME "gdb"
#endif /* !GDB_DEF_NAME */

#ifndef GDB_NAME_PREFIX
# define GDB_NAME_PREFIX ""
#endif /* !GDB_NAME_PREFIX */

int main(int argc, char **argv)
{
  kern_return_t kr;
  mach_msg_header_t msg;
  mach_port_t gdb_port;
  char *host;
  char *name;

  if (argc == 1) {
      argv[argc++] = (char *)GDB_DEF_NAME;
  }

  if (argc != 2) {
      fprintf(stderr, "Usage : %s <GDB name>\n", argv[0]);
      exit(1);
  }

  /* Allow the user to specify a remote host: */
  host = strchr(argv[1], '@');
  if (host) {
      *(host++) = '\0';
  } else {
      host = (char *)"";
  }

  name = (char *)xmalloc(strlen(argv[1]) + sizeof(GDB_NAME_PREFIX));
  if (name == NULL) {
      fprintf(stderr, "Unable to allocate memory for name.");
      exit(1);
  }

  strcpy(name, GDB_NAME_PREFIX);
  strcat(name, argv[1]);

  /* Look up the GDB service port. For convenience, add the
   * GDB_NAME_PREFIX the argument before looking up the name.
   * For backwards compatibility, do it without. */

  kr = netname_look_up(name_server_port, host, name, &gdb_port);
  if (kr == NETNAME_NOT_CHECKED_IN) {
      kr = netname_look_up(name_server_port, host, argv[1], &gdb_port);
  }
  if (kr != KERN_SUCCESS) {
      fprintf(stderr, "Unable to lookup the GDB service port: %s.\n",
	      mach_error_string(kr));
      exit(1);
  }

  /* Code generated by mig stub generator, with minor cleanups.
   *
   * simpleroutine stop_inferior(gdb_port : mach_port_t);  */

  msg.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0);
  msg.msgh_remote_port = gdb_port;
  msg.msgh_local_port = MACH_PORT_NULL;
  msg.msgh_size = sizeof(msg);
  /* FIXME: use proper condition: */
#if defined(HAVE_MACH_MSG_HEADER_T) && defined(__MACH__) && !defined(__APPLE__)
  msg.msgh_seqno = 0;
#endif /* HAVE_MACH_MSG_HEADER_T && __MACH__ && !__APPLE__ */
  msg.msgh_id = GDB_MESSAGE_ID_STOP;

  kr = mach_msg_send(&msg);
  if (kr != KERN_SUCCESS) {
    fprintf(stderr, "Message not sent, return code %d : %s\n", kr,
	    mach_error_string(kr));
  }

  exit(kr != KERN_SUCCESS);

  return 0;
}

/* EOF */
